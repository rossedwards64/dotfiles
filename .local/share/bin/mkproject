#!/usr/bin/env guile
!#

(use-modules (ice-9 format)
             (ice-9 getopt-long)
             (ice-9 optargs)
             (ice-9 popen)
             (oop goops)
             (srfi srfi-1))

(define (usage)
  "Script for making a new project with a main file, basic build system setup and flake.
  Usage: mkproject [-l language] [-p packages] [-d dir] [-h]
  l: Project language. Valid options are:
     c,
     c++,
     rust,
     lisp,
     scheme,
     clojure,
     scala
  p: Project packages.
  d: Project directory.
  h: Print usage.")

(define flake-template
  "{
    description = \"Flake generated by Ross' mkproject script.\";
    inputs = {
      nixpkgs.url = \"github:NixOS/nixpkgs/nixpkgs-unstable\";
      flake-utils.url = \"github:numtide/flake-utils\";
    };

    outputs = { nixpkgs, flake-utils, ... }:
      flake-utils.lib.eachDefaultSystem(
        system:
        let
          pkgs = import nixpkgs { inherit system; };
        in
        {
          devShell = pkgs.mkShell {
            nativeBuildInputs = with pkgs; [
              ~{~12t~a~^\n~}
            ];
            ~@[\n~:{~10t~a = ~a;~^\n~}~\n~]
            ~@[\n~10tshellHook = '''
              ~{~12t~a~^\n~}
            ''';~]
          };
        }
      );
  }")

(define cmakelists-template
  "cmake_minimum_required(VERSION 3.10)
  project(
    ~a
    DESCRIPTION \"CMakeLists.txt generated by Ross' mkproject script.\"
    LANGUAGES ~:@(~a~)
  )

  set(CMAKE_~:@(~a~)_STANDARD 23)
  set(CMAKE_~:@(~a~)_STANDARD_REQUIRED ON)
  set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

  set(SOURCES src/~a)

  add_compile_options(
    -Wall
    -Wpedantic
    -Werror
    -Wextra
    -Wshadow
    -Wpointer-arith
    -Wcast-align
    -Wwrite-strings
    -Wcast-qual
    -Wswitch-default
    -Wswitch-enum
    -Wunreachable-code
    -Wuninitialized
    -Winit-self
    ~:[~;-Wstrict-prototypes~]
    $<$<CONFIG:Debug>:-fsanitize=address>
    $<$<CONFIG:Debug>:-fsanitize=undefined>
    $<$<CONFIG:Debug>:-fno-omit-frame-pointer>
    $<$<CONFIG:Debug>:-g3>
  )

  add_executable(~a src/~a)
  target_sources(~a PRIVATE ${SOURCES})
  target_compile_definitions(
    ~a PRIVATE $<$<CONFIG:Debug>:DEBUG>
  )
  target_link_options(
    ~a BEFORE
    PRIVATE $<$<CONFIG:Debug>:-fsanitize=address>
    PRIVATE $<$<CONFIG:Debug>:-fsanitize=undefined>
  )")

(define sbcl-packages-template
  "(sbcl.withPackages (
  ~14tps: with ps; [
  ~16tasdf
  ~16t~{~a\n  ~}
  ~14t]
  ~12t))")

(define lisp-asd-template
  "(asdf:defsystem \"~a\"
    :description \"ASD file generated by Ross' mkproject script.\"
    :version \"0.1.0\"
    :author \"Ross Edwards redwards64@hotmail.com\"
    :license \"BSD\"
    :source-control (:git \"\")

    :depends-on ()
    :serial t
    :components ((:module \"src\"
                  :serial t
                  :components ((:file \"~a\"))))

    :build-operation \"program-op\"
    :build-pathname \"build/~a\"
    :entry-point \"~a:main\")
  ")

(define lisp-makefile-template
  "TARGET := ~a
  BUILD_DIR := build

  all: $(TARGET)

  $(TARGET):
  ~/sbcl --no-userinit --no-sysinit --non-interactive \\
  ~2/ --eval '(load (sb-ext:posix-getenv \"ASDF\"))' \\
  ~2/ --load ./~a.asd \\
  ~2/ --eval '(asdf:make :~a)' \\
  ~2/ --eval '(quit)'

  clean:
  ~/-rm -f $(BUILD_DIR)/$(TARGET)
  ")

(define missing-lang-or-dir-error "Must provide a language and directory.")

(define src-dir "src")

(define (resolve dirs)
  (reduce-right (lambda (r l)
                  (string-append r "/" l))
                "" dirs))

(define (file-name dir)
  (string-drop dir (+ (string-rindex dir #\/) 1)))

(define (file-name-no-ext file)
  (string-take file (string-index file #\.)))

(define-generic make-project)

(define-class <project> ()
  (packages
   #:init-keyword #:packages
   #:getter get-packages)
  (directory
   #:init-keyword #:directory
   #:getter get-directory))

(define-method (make-project (self <project>))
  (let ((directory (get-directory self)))
    (unless (file-exists? directory)
      (mkdir directory)
      (mkdir (resolve (list directory src-dir))))
    (write-file self ".envrc" "use flake")
    (setenv "GIT_DIR" (resolve (list directory ".git")))
    (system* "git" "init" "-q")
    (unsetenv "GIT_DIR")))

(define-method (write-file (self <project>) (filename <string>) (content <string>))
  (let ((directory (get-directory self)))
    (call-with-output-file (resolve (list directory filename))
      (lambda (output-port)
        (display content output-port)))))

(define-class <c-family-project> (<project>)
  (default-packages
    #:allocation #:each-subclass
    #:init-value
    '("clang-tools"
      "cmake"
      "cmake-language-server"
      "pkg-config"
      "valgrind")
    #:getter get-default-packages))

(define-method (make-project (self <c-family-project>))
  (next-method)
  (let ((main-file (get-main-file self))
        (content (get-main-file-content self)))
    (write-file self (resolve (list src-dir main-file))
                content))
  (make-cmakelists self)
  (make-flake self))

(define-class <c-project> (<c-family-project>)
  (main-file
   #:init-value "main.c"
   #:getter get-main-file)
  (main-file-content
   #:init-value "#include <stdio.h>
  #include <stdlib.h>

  int main(int argc, char **argv)
  {
      printf(\"Hello, world!\\n\");
      return EXIT_SUCCESS;
  }
  "
   #:getter get-main-file-content))

(define-class <c++-project> (<c-family-project>)
  (main-file
   #:init-value "main.cpp"
   #:getter get-main-file)
  (main-file-content
   #:init-value "#include <cstdlib>
  #include <print>

  auto main(int argc, char **argv) -> int
  {
      std::println(\"Hello, world!\");
      return EXIT_SUCCESS;
  }
  "
   #:getter get-main-file-content))

(define-generic make-cmakelists)

(define-method (make-cmakelists (self <c-family-project>) (language <symbol>))
  (let ((directory (file-name (get-directory self)))
        (main (get-main-file self)))
    (write-file self "CMakeLists.txt"
                (format #f cmakelists-template
                        directory language language
                        language main (if (eqv? language 'c) #t #f)
                        directory main directory
                        directory directory))))

(define-method (make-cmakelists (self <c-project>))
  (make-cmakelists self 'c))

(define-method (make-cmakelists (self <c++-project>))
  (make-cmakelists self 'cxx))

(define-class <rust-project> (<project>)
  (default-packages
    #:init-value
    '("cargo" "rust-analyzer" "rustPackages.clippy"
      "rustc" "rustfmt" "rustup")
    #:getter get-default-packages))

(define-method (make-project (self <rust-project>))
  (let* ((directory (get-directory self)))
    (system* "cargo" "new" directory))
  (next-method)
  (make-flake self
              #:vars '((RUST_SRC_PATH pkgs.rust.packages.stable.rustPlatform.rustLibSrc))
              #:shell-hook
              '("export CARGO_HOME=~/.local/share/cargo"
                "export RUSTUP_HOME=~/.local/share/rustup"
                "export PATH=$PATH:$RUSTUP_HOME/toolchains/stable-x86_64-w64-unknown-linux-gnu/bin/"
                "rustup default stable")))

(define-class <lisp-project> (<project>)
  (default-packages
    #:init-value
    '("roswell")
    #:getter get-default-packages)
  (lisp-packages
   #:init-keyword #:lisp-packages
   #:getter get-lisp-packages)
  (main-file
   #:init-keyword #:main-file
   #:getter get-main-file)
  (main-file-content
   #:init-value "(defpackage :~a
    (:use :cl)
    (:export #:main))
  (in-package :~a)

  (defun main ()
    (print \"Hello, world!\"))
  "
   #:getter get-main-file-content))

(define-method (make-project (self <lisp-project>))
  (next-method)
  (let* ((main-file (get-main-file self))
         (content (get-main-file-content self))
         (directory (get-directory self))
         (dir-name (file-name directory)))
    (write-file self (resolve (list src-dir main-file))
                (format #f content
                        dir-name dir-name))
    (write-file self "Makefile"
                (format #f lisp-makefile-template
                        dir-name dir-name dir-name)))
  (make-asd self)
  (make-flake self
              #:extra-packages (get-lisp-packages self)))

(define-method (initialize (self <lisp-project>) initargs)
  (let-keywords initargs #f (packages directory lisp-packages)
                (let ((sbcl-packages
                       (list (format #f sbcl-packages-template
                                     lisp-packages)))
                      (main-file (string-append (file-name directory) ".lisp")))
                  (next-method self (list #:packages packages
                                          #:directory directory
                                          #:lisp-packages sbcl-packages
                                          #:main-file main-file)))))

(define-method (make-asd (self <lisp-project>))
  (let* ((directory (get-directory self))
         (dir-name (file-name directory))
         (main (get-main-file self)))
    (write-file self (string-append dir-name ".asd")
                (format #f lisp-asd-template
                        dir-name (file-name-no-ext main)
                        dir-name dir-name))))

(define-class <scheme-project> (<project>)
  (default-packages
    #:init-value
    '("guile")
    #:getter get-default-packages)
  (main-file
   #:init-value "main.scm"
   #:getter get-main-file)
  (main-file-content
   #:init-value "(define (main)
    (display \"Hello, world!\\n\"))
  "
   #:getter get-main-file-content))

(define-method (make-project (self <scheme-project>))
  (next-method)
  (let ((main-file (get-main-file self))
        (content (get-main-file-content self)))
    (write-file self (resolve (list src-dir main-file))
                content))
  (make-flake self))

(define-class <clojure-project> (<project>)
  (default-packages
    #:init-value
    '("clojure" "clojure-lsp" "cljfmt"
      "clj-kondo" "leiningen")
    #:getter get-default-packages))

(define-method (make-project (self <clojure-project>))
  (let* ((directory (get-directory self)))
    (system* "lein" "new" (file-name directory) "--to-dir" directory))
  (next-method)
  (make-flake self))

(define-class <scala-project> (<project>)
  (default-packages
    #:init-value
    '("ammonite" "bloop" "coursier"
      "metals" "mill" "sbt"
      "scala-cli" "scalafmt")
    #:getter get-default-packages))

(define-method (make-project (self <scala-project>))
  (let ((directory (get-directory self))
        (pipe (open-output-pipe "sbt new scala/scala3.g8")))
    (display (file-name directory) pipe)
    (close-pipe pipe))
  (next-method)
  (make-flake self))

(define* (make-flake project #:key (extra-packages '()) (vars '()) (shell-hook '()))
  (let ((packages (append
                   (if (slot-exists? project 'default-packages)
                       (get-default-packages project)
                       '())
                   (get-packages project) extra-packages))
        (vars (if (null? vars) #f vars))
        (shell-hook (if (null? shell-hook) #f shell-hook)))
    (write-file project "flake.nix"
                (format #f flake-template
                        packages vars shell-hook))))

(define* (get-project language packages directory #:optional (extra-packages '()))
  (apply make (append
               (case language
                 ((c) (list <c-project>))
                 ((c++) (list <c++-project>))
                 ((rust) (list <rust-project>))
                 ((lisp) (list <lisp-project> #:lisp-packages extra-packages))
                 ((scheme) (list <scheme-project>))
                 ((clojure) (list <clojure-project>))
                 ((scala) (list <scala-project>))
                 (else (error (string-append
                               "Don't know how to make a "
                               (symbol->string language)
                               " project."))))
               (list #:packages packages #:directory directory))))

(let* ((option-spec '((language (single-char #\l) (value #t))
                      (packages (single-char #\p) (value #t))
                      (directory (single-char #\d) (value #t))
                      (help (single-char #\h) (value #f))))
       (options (getopt-long (command-line) option-spec))
       (language (string->symbol (option-ref options 'language "none")))
       (packages (option-ref options 'packages '()))
       (directory (option-ref options 'directory #f)))
  (cond
   ((not (nil? (option-ref options 'help #f)))
    (begin
      (display (usage))
      (newline)))
   ((or (eqv? language "none")
        (nil? directory))
    (error missing-lang-or-dir-error))
   (else
    (make-project
     (get-project language packages
                  (resolve (list
                            (canonicalize-path ".")
                            directory)))))))
